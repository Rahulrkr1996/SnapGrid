<!DOCTYPE html>
<html lang="en">
    <head>
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-7DHRE6VMDZ"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-7DHRE6VMDZ');
        </script>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <title>SnapGrid - Free Online Multi Image Crop Tool | Grid & Freehand</title>

        <meta name="description" content="SnapGrid is a free online multi-image crop tool. Crop images using grid mode or freehand mode for sprite sheets, UI, and game assets. No installation required.">
        <meta name="keywords" content="image crop tool, online image cropper, sprite sheet cutter, batch image crop, grid crop tool, freehand crop tool, snapgrid, image slicing tool">

        <link rel="canonical" href="https://rahulrkr1996.github.io/SnapGrid/">

        <!-- Open Graph (Social Preview) -->
        <meta property="og:title" content="SnapGrid ‚Äì Free Multi Image Crop Tool">
        <meta property="og:description" content="Easily crop images using grid or freehand mode for sprites, UI, and game assets.">
        <meta property="og:image" content="https://rahulrkr1996.github.io/SnapGrid/preview.png">
        <meta property="og:url" content="https://rahulrkr1996.github.io/SnapGrid/">
        <meta property="og:type" content="website">

        <!-- Twitter -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="SnapGrid ‚Äì Free Image Crop Tool">
        <meta name="twitter:description" content="Crop multiple images with grid or freehand mode. Perfect for sprite sheets and UI.">
        <meta name="twitter:image" content="https://rahulrkr1996.github.io/SnapGrid/">

        <link rel="stylesheet" href="styles.css">
        <!-- <style type="text/css">/* Reset & Base */        </style> -->
        <!-- ===== SCHEMA (Very Important for Google) ===== -->
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "WebApplication",
          "name": "SnapGrid",
          "url": "https://rahulrkr1996.github.io/SnapGrid/",
          "description": "Free online image cropping tool with grid and freehand modes for sprite sheets and game assets.",
          "applicationCategory": "DesignApplication",
          "operatingSystem": "Any",
          "creator": {
            "@type": "Person",
            "name": "Rahul Kumar",
            "url": "https://rahulrkr1996.github.io/"
          }
        }
        </script>
    </head>

    <body>
    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <div class="logo-section">
                <div class="logo-icon"><img src="CompanyLogo.png" alt="Company Logo" class="logo"></div>
                <div>
                    <div class="logo-text">SnapGrid</div>
                </div>
                <div class="logo-subtitle"> Free Online Multi Image Crop Tool</div>
            </div>
        </header>

        <!-- Main Workspace -->
        <div class="workspace">
            <!-- Left Panel -->
            <aside class="left-panel">
                <!-- Upload Section -->
                <div class="panel-section">
                    <button class="upload-btn" id="uploadBtn">
                        <span class="upload-icon">üìÅ</span>
                        <span>Choose Image</span>
                    </button>
                    <input type="file" id="imageInput" accept="image/*">
                </div>

                <!-- Mode Tabs -->
                <div class="panel-section" id="modeSection" style="display: none;">
                    <div class="section-title">Crop Mode</div>
                    <div class="mode-tabs">
                        <button class="mode-tab active" id="gridModeBtn">
                            <span class="mode-icon">‚ñ¶</span>
                            <span>Grid</span>
                        </button>
                        <button class="mode-tab" id="freehandModeBtn">
                            <span class="mode-icon">‚úèÔ∏è</span>
                            <span>Freehand</span>
                        </button>
                    </div>
                </div>

                <!-- Grid Controls -->
                <div class="panel-section" id="gridControls" style="display: none;">
                    <div class="section-title">Grid Settings</div>
                    <div class="controls-grid">
                        <div class="control-group">
                            <label class="control-label">Rows</label>
                            <input type="number" class="control-input" id="rows" value="2" min="1" max="20">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Columns</label>
                            <input type="number" class="control-input" id="cols" value="2" min="1" max="20">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Top Border</label>
                            <input type="number" class="control-input" id="topBorder" value="0" min="0">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Bottom Border</label>
                            <input type="number" class="control-input" id="bottomBorder" value="50" min="0">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Left Border</label>
                            <input type="number" class="control-input" id="leftBorder" value="0" min="0">
                        </div>
                        <div class="control-group">
                            <label class="control-label">Right Border</label>
                            <input type="number" class="control-input" id="rightBorder" value="50" min="0">
                        </div>
                        <div class="control-group">
                            <label class="control-label">H. Margin</label>
                            <input type="number" class="control-input" id="marginX" value="0" min="0">
                        </div>
                        <div class="control-group">
                            <label class="control-label">V. Margin</label>
                            <input type="number" class="control-input" id="marginY" value="0" min="0">
                        </div>
                    </div>

                    <div class="action-buttons">
                        <button class="btn btn-primary" id="applyGridBtn">
                            <span>‚úì</span>
                            <span>Apply Grid</span>
                        </button>
                        <button class="btn btn-primary" id="sliceGridBtn">
                            <span>‚úÇÔ∏è</span>
                            <span>Slice Image</span>
                        </button>
                    </div>
                </div>

                <!-- Freehand Controls -->
                <div class="panel-section hidden" id="freehandControls">
                    <div class="section-title">Freehand Tools</div>
                    
                    <div class="freehand-hint">
                        <div class="hint-item">
                            <span class="hint-icon">üñ±Ô∏è</span>
                            <span>Click and drag to draw regions</span>
                        </div>
                        <div class="hint-item">
                            <span class="hint-icon">‚úã</span>
                            <span>Click regions to move them</span>
                        </div>
                        <div class="hint-item">
                            <span class="hint-icon">üìè</span>
                            <span>Drag handles to resize</span>
                        </div>
                    </div>

                    <div class="action-buttons">
                        <button class="btn btn-primary" id="sliceFreehandBtn">
                            <span>‚úÇÔ∏è</span>
                            <span>Slice Regions</span>
                        </button>
                        <button class="btn btn-danger" id="clearRegionsBtn">
                            <span>üóëÔ∏è</span>
                            <span>Clear All</span>
                        </button>
                    </div>

                    <!-- Regions List -->
                    <div id="regionsList" class="hidden">
                        <div class="regions-header">
                            <div class="section-title" style="margin: 0;">Regions</div>
                            <div class="regions-count" id="regionCount">0</div>
                        </div>
                        <div class="regions-panel" id="regionsContainer"></div>
                    </div>
                </div>

                <!-- Reset Button -->
                <div class="panel-section">
                    <button class="btn btn-secondary" id="resetBtn" style="width: 100%;">
                        <span>‚Üª</span>
                        <span>Reset All</span>
                    </button>
                </div>
            </aside>

            <!-- Right Panel -->
            <main class="right-panel">
                <div class="canvas-header">
                    <div class="canvas-title">Canvas Preview</div>
                </div>

                <div class="canvas-workspace" id="canvasWorkspace">
                    <div class="empty-state" id="emptyState">
                        <div class="empty-icon">üé®</div>
                        <div class="empty-title">No Image Loaded</div>
                        <div class="empty-text">Upload an image to get started</div>
                    </div>
                    <div class="canvas-container hidden" id="canvasContainer">
                        <canvas id="previewCanvas"></canvas>
                    </div>
                </div>
            </main>
        </div>

        <!-- Cropped Images Section -->
        <div class="cropped-section" id="croppedSection">
            <div class="cropped-header">
                <div class="cropped-title">
                    <span>Sliced Images</span>
                    <span class="image-count-badge" id="imageCount">0</span>
                </div>
                <button class="btn btn-primary" id="exportAllBtn">
                    <span>üì¶</span>
                    <span>Export All</span>
                </button>
            </div>
            <div class="cropped-content">
                <div class="image-grid" id="imageGrid"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script>
        let sourceImage = null;
        let croppedImages = [];
        let currentMode = 'grid';
        let freehandRegions = [];
        let isDrawing = false;
        let startX, startY;
        let currentRect = null;
        let selectedRegion = null;
        let isDragging = false;
        let isResizing = false;
        let resizeHandle = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;
        const handleSize = ('ontouchstart' in window) ? 16 : 8; // Larger handles for touch devices

        const uploadBtn = document.getElementById('uploadBtn');
        const imageInput = document.getElementById('imageInput');
        const modeSection = document.getElementById('modeSection');
        const gridModeBtn = document.getElementById('gridModeBtn');
        const freehandModeBtn = document.getElementById('freehandModeBtn');
        const gridControls = document.getElementById('gridControls');
        const freehandControls = document.getElementById('freehandControls');
        const emptyState = document.getElementById('emptyState');
        const canvasContainer = document.getElementById('canvasContainer');
        const previewCanvas = document.getElementById('previewCanvas');
        const ctx = previewCanvas.getContext('2d');
        const croppedSection = document.getElementById('croppedSection');
        const imageGrid = document.getElementById('imageGrid');

        // Upload
        uploadBtn.addEventListener('click', () => imageInput.click());
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImage(file);
        });

        // Mobile-friendly drag and drop on upload button
        uploadBtn.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadBtn.style.transform = 'scale(1.02)';
        });

        uploadBtn.addEventListener('dragleave', () => {
            uploadBtn.style.transform = '';
        });

        uploadBtn.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadBtn.style.transform = '';
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                loadImage(file);
            }
        });

        function loadImage(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    sourceImage = img;
                    emptyState.classList.add('hidden');
                    canvasContainer.classList.remove('hidden');
                    modeSection.style.display = 'block';
                    gridControls.style.display = 'block';
                    freehandRegions = [];
                    updatePreview();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // Mode Switching
        gridModeBtn.addEventListener('click', () => {
            currentMode = 'grid';
            gridModeBtn.classList.add('active');
            freehandModeBtn.classList.remove('active');
            gridControls.style.display = 'block';
            freehandControls.classList.add('hidden');
            previewCanvas.style.cursor = 'default';
            updatePreview();
        });

        freehandModeBtn.addEventListener('click', () => {
            currentMode = 'freehand';
            freehandModeBtn.classList.add('active');
            gridModeBtn.classList.remove('active');
            gridControls.style.display = 'none';
            freehandControls.classList.remove('hidden');
            previewCanvas.style.cursor = 'crosshair';
            updatePreview();
        });

        // Canvas Events - Mouse
        previewCanvas.addEventListener('mousedown', handlePointerDown);
        previewCanvas.addEventListener('mousemove', handlePointerMove);
        previewCanvas.addEventListener('mouseup', handlePointerUp);
        previewCanvas.addEventListener('mouseleave', handlePointerLeave);

        // Canvas Events - Touch
        previewCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handlePointerDown(mouseEvent);
        }, { passive: false });

        previewCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            handlePointerMove(mouseEvent);
        }, { passive: false });

        previewCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handlePointerUp();
        }, { passive: false });

        previewCanvas.addEventListener('touchcancel', (e) => {
            e.preventDefault();
            handlePointerLeave();
        }, { passive: false });

        function handlePointerDown(e) {
            if (currentMode !== 'freehand' || !sourceImage) return;
            
            const rect = previewCanvas.getBoundingClientRect();
            const scaleX = sourceImage.width / rect.width;
            const scaleY = sourceImage.height / rect.height;
            
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            
            const handleInfo = getResizeHandle(mouseX, mouseY);
            if (handleInfo) {
                isResizing = true;
                selectedRegion = handleInfo.regionIndex;
                resizeHandle = handleInfo.handle;
                return;
            }
            
            const clickedRegion = getRegionAtPoint(mouseX, mouseY);
            if (clickedRegion !== null) {
                selectedRegion = clickedRegion;
                isDragging = true;
                const region = freehandRegions[clickedRegion];
                dragOffsetX = mouseX - region.x;
                dragOffsetY = mouseY - region.y;
                updatePreview();
                return;
            }
            
            selectedRegion = null;
            startX = mouseX;
            startY = mouseY;
            isDrawing = true;
            currentRect = { x: startX, y: startY, width: 0, height: 0 };
        }

        function handlePointerMove(e) {
            if (currentMode !== 'freehand') return;
            
            const rect = previewCanvas.getBoundingClientRect();
            const scaleX = sourceImage.width / rect.width;
            const scaleY = sourceImage.height / rect.height;
            
            const mouseX = (e.clientX - rect.left) * scaleX;
            const mouseY = (e.clientY - rect.top) * scaleY;
            
            if (isResizing && selectedRegion !== null) {
                const region = freehandRegions[selectedRegion];
                
                switch(resizeHandle) {
                    case 'nw':
                        const newWidth1 = region.width + (region.x - mouseX);
                        const newHeight1 = region.height + (region.y - mouseY);
                        if (newWidth1 > 10 && newHeight1 > 10) {
                            region.x = mouseX;
                            region.y = mouseY;
                            region.width = newWidth1;
                            region.height = newHeight1;
                        }
                        break;
                    case 'ne':
                        const newWidth2 = mouseX - region.x;
                        const newHeight2 = region.height + (region.y - mouseY);
                        if (newWidth2 > 10 && newHeight2 > 10) {
                            region.y = mouseY;
                            region.width = newWidth2;
                            region.height = newHeight2;
                        }
                        break;
                    case 'sw':
                        const newWidth3 = region.width + (region.x - mouseX);
                        const newHeight3 = mouseY - region.y;
                        if (newWidth3 > 10 && newHeight3 > 10) {
                            region.x = mouseX;
                            region.width = newWidth3;
                            region.height = newHeight3;
                        }
                        break;
                    case 'se':
                        region.width = mouseX - region.x;
                        region.height = mouseY - region.y;
                        if (region.width < 10) region.width = 10;
                        if (region.height < 10) region.height = 10;
                        break;
                    case 'n':
                        const newHeight5 = region.height + (region.y - mouseY);
                        if (newHeight5 > 10) {
                            region.y = mouseY;
                            region.height = newHeight5;
                        }
                        break;
                    case 's':
                        region.height = mouseY - region.y;
                        if (region.height < 10) region.height = 10;
                        break;
                    case 'w':
                        const newWidth6 = region.width + (region.x - mouseX);
                        if (newWidth6 > 10) {
                            region.x = mouseX;
                            region.width = newWidth6;
                        }
                        break;
                    case 'e':
                        region.width = mouseX - region.x;
                        if (region.width < 10) region.width = 10;
                        break;
                }
                
                updateRegionsList();
                updatePreview();
                return;
            }
            
            if (isDragging && selectedRegion !== null) {
                const region = freehandRegions[selectedRegion];
                region.x = Math.max(0, Math.min(mouseX - dragOffsetX, sourceImage.width - region.width));
                region.y = Math.max(0, Math.min(mouseY - dragOffsetY, sourceImage.height - region.height));
                updatePreview();
                return;
            }
            
            if (isDrawing) {
                currentRect.width = mouseX - startX;
                currentRect.height = mouseY - startY;
                updatePreview();
                return;
            }
            
            const handleInfo = getResizeHandle(mouseX, mouseY);
            if (handleInfo) {
                const cursors = {
                    'nw': 'nw-resize', 'ne': 'ne-resize',
                    'sw': 'sw-resize', 'se': 'se-resize',
                    'n': 'n-resize', 's': 's-resize',
                    'w': 'w-resize', 'e': 'e-resize'
                };
                previewCanvas.style.cursor = cursors[handleInfo.handle];
            } else if (getRegionAtPoint(mouseX, mouseY) !== null) {
                previewCanvas.style.cursor = 'move';
            } else {
                previewCanvas.style.cursor = 'crosshair';
            }
        }

        function handlePointerUp(e) {
            if (currentMode !== 'freehand') return;
            
            if (isResizing) {
                isResizing = false;
                resizeHandle = null;
                updatePreview();
                return;
            }
            
            if (isDragging) {
                isDragging = false;
                updatePreview();
                return;
            }
            
            if (isDrawing) {
                isDrawing = false;
                
                if (Math.abs(currentRect.width) > 10 && Math.abs(currentRect.height) > 10) {
                    const normalizedRect = {
                        x: currentRect.width < 0 ? startX + currentRect.width : startX,
                        y: currentRect.height < 0 ? startY + currentRect.height : startY,
                        width: Math.abs(currentRect.width),
                        height: Math.abs(currentRect.height)
                    };
                    
                    freehandRegions.push(normalizedRect);
                    selectedRegion = freehandRegions.length - 1;
                    updateRegionsList();
                }
                
                currentRect = null;
                updatePreview();
            }
        }

        function handlePointerLeave() {
            if (isDrawing) {
                isDrawing = false;
                currentRect = null;
                updatePreview();
            }
            if (isDragging) isDragging = false;
            if (isResizing) {
                isResizing = false;
                resizeHandle = null;
            }
            previewCanvas.style.cursor = 'crosshair';
        }

        function updateRegionsList() {
            const regionsList = document.getElementById('regionsList');
            const regionsContainer = document.getElementById('regionsContainer');
            
            if (freehandRegions.length === 0) {
                regionsList.classList.add('hidden');
                return;
            }

            regionsList.classList.remove('hidden');
            document.getElementById('regionCount').textContent = freehandRegions.length;
            regionsContainer.innerHTML = '';

            freehandRegions.forEach((region, index) => {
                const card = document.createElement('div');
                card.className = 'region-card';
                card.innerHTML = `
                    <div>
                        <div class="region-info">Region ${index + 1}</div>
                        <div class="region-size">${Math.round(region.width)} √ó ${Math.round(region.height)}px</div>
                    </div>
                    <button class="region-delete" onclick="deleteRegion(${index})">√ó</button>
                `;
                regionsContainer.appendChild(card);
            });
        }

        function deleteRegion(index) {
            freehandRegions.splice(index, 1);
            if (selectedRegion === index) {
                selectedRegion = null;
            } else if (selectedRegion > index) {
                selectedRegion--;
            }
            updateRegionsList();
            updatePreview();
        }

        function getRegionAtPoint(x, y) {
            for (let i = freehandRegions.length - 1; i >= 0; i--) {
                const region = freehandRegions[i];
                if (x >= region.x && x <= region.x + region.width &&
                    y >= region.y && y <= region.y + region.height) {
                    return i;
                }
            }
            return null;
        }

        function getResizeHandle(x, y) {
            for (let i = freehandRegions.length - 1; i >= 0; i--) {
                const region = freehandRegions[i];
                const handles = getHandlePositions(region);
                
                for (const [handle, pos] of Object.entries(handles)) {
                    if (Math.abs(x - pos.x) <= handleSize && Math.abs(y - pos.y) <= handleSize) {
                        return { regionIndex: i, handle };
                    }
                }
            }
            return null;
        }

        function getHandlePositions(region) {
            return {
                'nw': { x: region.x, y: region.y },
                'ne': { x: region.x + region.width, y: region.y },
                'sw': { x: region.x, y: region.y + region.height },
                'se': { x: region.x + region.width, y: region.y + region.height },
                'n': { x: region.x + region.width / 2, y: region.y },
                's': { x: region.x + region.width / 2, y: region.y + region.height },
                'w': { x: region.x, y: region.y + region.height / 2 },
                'e': { x: region.x + region.width, y: region.y + region.height / 2 }
            };
        }

        function drawResizeHandles(region, isSelected) {
            const handles = getHandlePositions(region);
            
            ctx.fillStyle = isSelected ? '#FF8FA3' : '#8B7FD9';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            
            for (const pos of Object.values(handles)) {
                ctx.fillRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
                ctx.strokeRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
            }
        }

        document.getElementById('clearRegionsBtn').addEventListener('click', () => {
            freehandRegions = [];
            selectedRegion = null;
            updateRegionsList();
            updatePreview();
        });

        function updatePreview() {
            if (!sourceImage) return;

            previewCanvas.width = sourceImage.width;
            previewCanvas.height = sourceImage.height;
            ctx.drawImage(sourceImage, 0, 0);

            if (currentMode === 'grid') {
                drawGridPreview();
            } else {
                drawFreehandPreview();
            }
        }

        function drawGridPreview() {
            const top = parseInt(document.getElementById('topBorder').value);
            const bottom = parseInt(document.getElementById('bottomBorder').value);
            const left = parseInt(document.getElementById('leftBorder').value);
            const right = parseInt(document.getElementById('rightBorder').value);
            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            const marginX = parseInt(document.getElementById('marginX').value);
            const marginY = parseInt(document.getElementById('marginY').value);

            const x0 = left;
            const y0 = top;
            const x1 = sourceImage.width - right;
            const y1 = sourceImage.height - bottom;

            ctx.strokeStyle = '#FF8FA3';
            ctx.lineWidth = 2;
            ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);

            const availableWidth = x1 - x0 - (cols - 1) * marginX;
            const availableHeight = y1 - y0 - (rows - 1) * marginY;
            const cellW = availableWidth / cols;
            const cellH = availableHeight / rows;

            ctx.strokeStyle = '#8B7FD9';
            ctx.lineWidth = 2;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cellX = x0 + c * (cellW + marginX);
                    const cellY = y0 + r * (cellH + marginY);
                    ctx.strokeRect(cellX, cellY, cellW, cellH);
                }
            }

            if (marginX > 0 || marginY > 0) {
                ctx.fillStyle = 'rgba(111, 180, 232, 0.2)';
                
                for (let c = 1; c < cols; c++) {
                    const marginStartX = x0 + c * cellW + (c - 1) * marginX;
                    ctx.fillRect(marginStartX, y0, marginX, y1 - y0);
                }
                
                for (let r = 1; r < rows; r++) {
                    const marginStartY = y0 + r * cellH + (r - 1) * marginY;
                    ctx.fillRect(x0, marginStartY, x1 - x0, marginY);
                }
            }
        }

        function drawFreehandPreview() {
            freehandRegions.forEach((region, index) => {
                const isSelected = index === selectedRegion;
                
                ctx.strokeStyle = isSelected ? '#FF8FA3' : '#8B7FD9';
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.strokeRect(region.x, region.y, region.width, region.height);
                
                if (isSelected) {
                    ctx.fillStyle = 'rgba(255, 143, 163, 0.1)';
                    ctx.fillRect(region.x, region.y, region.width, region.height);
                }
                
                drawResizeHandles(region, isSelected);
                
                ctx.fillStyle = isSelected ? '#FF8FA3' : '#8B7FD9';
                ctx.font = 'bold 16px DM Sans';
                ctx.fillText(`#${index + 1}`, region.x + 5, region.y + 20);
            });

            if (isDrawing && currentRect) {
                ctx.strokeStyle = '#6FB4E8';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                ctx.setLineDash([]);
            }
        }

        function cropImages() {
            if (!sourceImage) return;

            croppedImages = [];
            imageGrid.innerHTML = '';

            if (currentMode === 'grid') {
                cropGridMode();
            } else {
                cropFreehandMode();
            }

            document.getElementById('imageCount').textContent = croppedImages.length;
            croppedSection.classList.add('visible');
        }

        function cropGridMode() {
            const top = parseInt(document.getElementById('topBorder').value);
            const bottom = parseInt(document.getElementById('bottomBorder').value);
            const left = parseInt(document.getElementById('leftBorder').value);
            const right = parseInt(document.getElementById('rightBorder').value);
            const rows = parseInt(document.getElementById('rows').value);
            const cols = parseInt(document.getElementById('cols').value);
            const marginX = parseInt(document.getElementById('marginX').value);
            const marginY = parseInt(document.getElementById('marginY').value);

            const x0 = left;
            const y0 = top;
            const x1 = sourceImage.width - right;
            const y1 = sourceImage.height - bottom;

            const availableWidth = x1 - x0 - (cols - 1) * marginX;
            const availableHeight = y1 - y0 - (rows - 1) * marginY;
            const cellW = Math.floor(availableWidth / cols);
            const cellH = Math.floor(availableHeight / rows);

            let index = 1;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const sx = x0 + c * (cellW + marginX);
                    const sy = y0 + r * (cellH + marginY);

                    const canvas = document.createElement('canvas');
                    canvas.width = cellW;
                    canvas.height = cellH;
                    const cellCtx = canvas.getContext('2d');

                    cellCtx.drawImage(sourceImage, sx, sy, cellW, cellH, 0, 0, cellW, cellH);

                    const dataUrl = canvas.toDataURL('image/png');
                    const imageName = `cropped_${index}`;
                    croppedImages.push({ index, name: imageName, dataUrl });

                    createImageCard(index - 1, imageName, dataUrl);
                    index++;
                }
            }
        }

        function cropFreehandMode() {
            if (freehandRegions.length === 0) {
                alert('Please draw at least one region to crop!');
                return;
            }

            freehandRegions.forEach((region, index) => {
                const canvas = document.createElement('canvas');
                canvas.width = Math.floor(region.width);
                canvas.height = Math.floor(region.height);
                const cellCtx = canvas.getContext('2d');

                cellCtx.drawImage(sourceImage, region.x, region.y, region.width, region.height, 0, 0, region.width, region.height);

                const dataUrl = canvas.toDataURL('image/png');
                const imageName = `region_${index + 1}`;
                croppedImages.push({ index: index + 1, name: imageName, dataUrl });

                createImageCard(index, imageName, dataUrl);
            });
        }

        function createImageCard(index, name, dataUrl) {
            const card = document.createElement('div');
            card.className = 'image-card fade-in';
            card.innerHTML = `
                <img src="${dataUrl}" alt="${name}">
                <div class="image-overlay">
                    <div class="image-name" onclick="editImageName(${index}, event)">
                        ${name}
                    </div>
                    <button class="image-download" onclick="downloadImage(${index})">‚Üì</button>
                </div>
            `;
            imageGrid.appendChild(card);
        }

        function editImageName(index, event) {
            event.stopPropagation();
            const nameDiv = event.target;
            const currentName = nameDiv.textContent.trim();
            
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.className = 'image-name';
            input.style.width = '100%';
            
            nameDiv.parentNode.replaceChild(input, nameDiv);
            input.focus();
            input.select();
            
            const finishEdit = () => {
                const newName = input.value.trim() || currentName;
                croppedImages[index].name = newName;
                
                const newDiv = document.createElement('div');
                newDiv.className = 'image-name';
                newDiv.onclick = (e) => editImageName(index, e);
                newDiv.textContent = newName;
                input.parentNode.replaceChild(newDiv, input);
            };
            
            input.addEventListener('blur', finishEdit);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') finishEdit();
            });
        }

        function downloadImage(index) {
            const link = document.createElement('a');
            link.download = `${croppedImages[index].name}.png`;
            link.href = croppedImages[index].dataUrl;
            link.click();
        }

        async function downloadAllAsZip() {
            const zip = new JSZip();
            
            croppedImages.forEach((img) => {
                const base64Data = img.dataUrl.split(',')[1];
                zip.file(`${img.name}.png`, base64Data, { base64: true });
            });

            const blob = await zip.generateAsync({ type: 'blob' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'snapgrid_export.zip';
            link.click();
        }

        function reset() {
            sourceImage = null;
            croppedImages = [];
            freehandRegions = [];
            selectedRegion = null;
            imageInput.value = '';
            emptyState.classList.remove('hidden');
            canvasContainer.classList.add('hidden');
            modeSection.style.display = 'none';
            gridControls.style.display = 'none';
            freehandControls.classList.add('hidden');
            croppedSection.classList.remove('visible');
            imageGrid.innerHTML = '';
            ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            updateRegionsList();
        }

        // Event Listeners
        document.getElementById('applyGridBtn').addEventListener('click', updatePreview);
        document.getElementById('sliceGridBtn').addEventListener('click', cropImages);
        document.getElementById('sliceFreehandBtn').addEventListener('click', cropImages);
        document.getElementById('exportAllBtn').addEventListener('click', downloadAllAsZip);
        document.getElementById('resetBtn').addEventListener('click', reset);

        ['topBorder', 'bottomBorder', 'leftBorder', 'rightBorder', 'rows', 'cols', 'marginX', 'marginY'].forEach(id => {
            document.getElementById(id).addEventListener('input', () => {
                if (currentMode === 'grid') updatePreview();
            });
        });
    </script>
    </body>
</html>