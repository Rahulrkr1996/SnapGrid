<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-RZ084SCH20"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-RZ084SCH20');
        </script>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <title>SnapGrid - Free Online Multi Image Crop Tool | Grid & Freehand</title>

        <meta name="description" content="SnapGrid is a free online multi-image crop tool. Crop images using grid mode or freehand mode for sprite sheets, UI, and game assets. No installation required.">
        <meta name="keywords" content="image crop tool, online image cropper, sprite sheet cutter, batch image crop, grid crop tool, freehand crop tool, snapgrid, image slicing tool">

        <link rel="canonical" href="https://rahulrkr1996.github.io/SnapGrid/">

        <!-- Open Graph (Social Preview) -->
        <meta property="og:title" content="SnapGrid – Free Multi Image Crop Tool">
        <meta property="og:description" content="Easily crop images using grid or freehand mode for sprites, UI, and game assets.">
        <meta property="og:image" content="https://rahulrkr1996.github.io/SnapGrid/preview.png">
        <meta property="og:url" content="https://rahulrkr1996.github.io/SnapGrid/">
        <meta property="og:type" content="website">

        <!-- Twitter -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="SnapGrid – Free Image Crop Tool">
        <meta name="twitter:description" content="Crop multiple images with grid or freehand mode. Perfect for sprite sheets and UI.">
        <meta name="twitter:image" content="https://rahulrkr1996.github.io/SnapGrid/">

        <link rel="stylesheet" href="style.css">

        <!-- ===== SCHEMA (Very Important for Google) ===== -->
        <script type="application/ld+json">
        {
          "@context": "https://schema.org",
          "@type": "WebApplication",
          "name": "SnapGrid",
          "url": "https://rahulrkr1996.github.io/SnapGrid/",
          "description": "Free online image cropping tool with grid and freehand modes for sprite sheets and game assets.",
          "applicationCategory": "DesignApplication",
          "operatingSystem": "Any",
          "creator": {
            "@type": "Person",
            "name": "Rahul Kumar",
            "url": "https://rahulrkr1996.github.io/"
          }
        }
        </script>
    </head>

    <body>
        <!-- Header -->
        <header class="app-header">
            <div class="header-left">
                <img src="CompanyLogo.png" alt="SnapGrid Logo" class="logo">
                <h1 class="app-title">SnapGrid</h1>
            </div>
            <div class="header-right">
                <p class="tagline">Slice images beautifully</p>
            </div>
        </header>

        <!-- Main Workspace -->
        <div class="workspace">
            <!-- Left Panel: Tools & Controls -->
            <aside class="left-panel">
                <!-- Upload Section -->
                <div class="upload-section" id="uploadSection">
                    <div class="upload-card" id="uploadArea">
                        <i data-feather="upload-cloud" class="upload-icon"></i>
                        <h3>Upload Image</h3>
                        <p>Drop your image here or click to browse</p>
                        <input type="file" id="imageInput" accept="image/*">
                    </div>
                </div>

                <!-- Tools Section (Hidden initially) -->
                <div class="tools-section hidden" id="toolsSection">
                    <!-- Mode Selector -->
                    <div class="mode-toggle">
                        <button class="mode-tab active" id="gridModeBtn">
                            <i data-feather="grid"></i>
                            <span>Grid Mode</span>
                        </button>
                        <button class="mode-tab" id="freehandModeBtn">
                            <i data-feather="edit-3"></i>
                            <span>Freehand</span>
                        </button>
                    </div>

                    <!-- Grid Mode Controls -->
                    <div class="controls-card" id="gridControls">
                        <h3 class="card-title">Grid Settings</h3>
                        
                        <div class="control-section">
                            <label class="control-label">Layout</label>
                            <div class="control-row">
                                <div class="control-group">
                                    <label>Rows</label>
                                    <input type="number" id="rows" value="2" min="1" max="20">
                                </div>
                                <div class="control-group">
                                    <label>Columns</label>
                                    <input type="number" id="cols" value="2" min="1" max="20">
                                </div>
                            </div>
                        </div>

                        <div class="control-section">
                            <label class="control-label">Spacing</label>
                            <div class="control-row">
                                <div class="control-group">
                                    <label>Horizontal</label>
                                    <input type="number" id="marginX" value="0" min="0">
                                </div>
                                <div class="control-group">
                                    <label>Vertical</label>
                                    <input type="number" id="marginY" value="0" min="0">
                                </div>
                            </div>
                        </div>

                        <div class="control-section">
                            <label class="control-label">Borders (px)</label>
                            <div class="control-row">
                                <div class="control-group">
                                    <label>Top</label>
                                    <input type="number" id="topBorder" value="0" min="0">
                                </div>
                                <div class="control-group">
                                    <label>Bottom</label>
                                    <input type="number" id="bottomBorder" value="50" min="0">
                                </div>
                            </div>
                            <div class="control-row">
                                <div class="control-group">
                                    <label>Left</label>
                                    <input type="number" id="leftBorder" value="0" min="0">
                                </div>
                                <div class="control-group">
                                    <label>Right</label>
                                    <input type="number" id="rightBorder" value="50" min="0">
                                </div>
                            </div>
                        </div>

                        <button class="btn-primary" id="updatePreview">
                            <i data-feather="refresh-cw"></i>
                            <span>Apply Grid</span>
                        </button>
                    </div>

                    <!-- Freehand Mode Controls -->
                    <div class="controls-card hidden" id="freehandControls">
                        <h3 class="card-title">Draw Regions</h3>
                        
                        <div class="instructions-card">
                            <div class="instruction-item">
                                <i data-feather="mouse-pointer"></i>
                                <span>Click & drag to draw</span>
                            </div>
                            <div class="instruction-item">
                                <i data-feather="move"></i>
                                <span>Drag regions to move</span>
                            </div>
                            <div class="instruction-item">
                                <i data-feather="maximize-2"></i>
                                <span>Resize with handles</span>
                            </div>
                        </div>

                        <div id="regionsList" class="regions-panel hidden">
                            <div class="regions-header">
                                <h4>Regions (<span id="regionCount">0</span>)</h4>
                                <button class="btn-ghost btn-sm" id="clearRegions">
                                    <i data-feather="trash-2"></i>
                                    Clear All
                                </button>
                            </div>
                            <div id="regionsContainer" class="regions-list"></div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="action-buttons">
                        <button class="btn-accent" id="cropButton">
                            <i data-feather="scissors"></i>
                            <span>Slice Image</span>
                        </button>
                        <button class="btn-ghost" id="resetButton">
                            <i data-feather="rotate-ccw"></i>
                            <span>Reset</span>
                        </button>
                    </div>
                </div>
            </aside>

            <!-- Right Panel: Canvas Workspace -->
            <main class="canvas-panel">
                <div class="canvas-container" id="canvasContainer">
                    <div class="empty-state" id="emptyState">
                        <i data-feather="image" class="empty-icon"></i>
                        <h2>Ready to Slice</h2>
                        <p>Upload an image to get started</p>
                    </div>
                    <canvas id="previewCanvas"></canvas>
                </div>

                <!-- Cropped Images Section -->
                <div id="croppedSection" class="cropped-section hidden">
                    <div class="cropped-header">
                        <h2>Cropped Images (<span id="imageCount">0</span>)</h2>
                        <button class="btn-primary" id="downloadAllButton">
                            <i data-feather="download"></i>
                            <span>Export Crops</span>
                        </button>
                    </div>
                    <div class="image-grid" id="croppedGrid"></div>
                </div>
            </main>
        </div>

        <!-- SEO Content (Hidden) -->
        <div class="seo-content" style="position: absolute; left: -9999px;">
            <h2>What is SnapGrid?</h2>
            <p>
            SnapGrid is a free online image cropping tool designed for developers, artists, and game creators. 
            It allows you to split images into multiple parts using grid mode or draw custom regions using freehand mode. 
            Perfect for sprite sheets, UI assets, and batch image slicing.
            </p>
        </div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <script>
            let sourceImage = null;
            let croppedImages = [];
            let currentMode = 'grid';
            let freehandRegions = [];
            let isDrawing = false;
            let startX, startY;
            let currentRect = null;
            let selectedRegion = null;
            let isDragging = false;
            let isResizing = false;
            let resizeHandle = null;
            let dragOffsetX = 0;
            let dragOffsetY = 0;
            const handleSize = 8;

            const uploadArea = document.getElementById('uploadArea');
            const imageInput = document.getElementById('imageInput');
            const uploadSection = document.getElementById('uploadSection');
            const toolsSection = document.getElementById('toolsSection');
            const previewCanvas = document.getElementById('previewCanvas');
            const ctx = previewCanvas.getContext('2d');
            const croppedSection = document.getElementById('croppedSection');
            const croppedGrid = document.getElementById('croppedGrid');
            const emptyState = document.getElementById('emptyState');
            const canvasContainer = document.getElementById('canvasContainer');

            const gridModeBtn = document.getElementById('gridModeBtn');
            const freehandModeBtn = document.getElementById('freehandModeBtn');
            const gridControls = document.getElementById('gridControls');
            const freehandControls = document.getElementById('freehandControls');
            const clearRegionsBtn = document.getElementById('clearRegions');
            const regionsList = document.getElementById('regionsList');
            const regionsContainer = document.getElementById('regionsContainer');

            // Initialize Feather icons
            feather.replace();

            // Upload area interactions
            uploadArea.addEventListener('click', () => imageInput.click());
            
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', () => {
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    loadImage(file);
                }
            });

            imageInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    loadImage(file);
                }
            });

            function loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        sourceImage = img;
                        uploadSection.style.display = 'none';
                        toolsSection.classList.remove('hidden');
                        emptyState.style.display = 'none';
                        previewCanvas.style.display = 'block';
                        freehandRegions = [];
                        updatePreview();
                        feather.replace();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            // Mode switching
            gridModeBtn.addEventListener('click', () => {
                currentMode = 'grid';
                gridModeBtn.classList.add('active');
                freehandModeBtn.classList.remove('active');
                gridControls.classList.remove('hidden');
                freehandControls.classList.add('hidden');
                previewCanvas.style.cursor = 'default';
                updatePreview();
            });

            freehandModeBtn.addEventListener('click', () => {
                currentMode = 'freehand';
                freehandModeBtn.classList.add('active');
                gridModeBtn.classList.remove('active');
                gridControls.classList.add('hidden');
                freehandControls.classList.remove('hidden');
                previewCanvas.style.cursor = 'crosshair';
                updatePreview();
            });

            // Canvas mouse events for freehand mode
            previewCanvas.addEventListener('mousedown', (e) => {
                if (currentMode !== 'freehand' || !sourceImage) return;
                
                const rect = previewCanvas.getBoundingClientRect();
                const scaleX = sourceImage.width / rect.width;
                const scaleY = sourceImage.height / rect.height;
                
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                const handleInfo = getResizeHandle(mouseX, mouseY);
                if (handleInfo) {
                    isResizing = true;
                    selectedRegion = handleInfo.regionIndex;
                    resizeHandle = handleInfo.handle;
                    return;
                }
                
                const clickedRegion = getRegionAtPoint(mouseX, mouseY);
                if (clickedRegion !== null) {
                    selectedRegion = clickedRegion;
                    isDragging = true;
                    const region = freehandRegions[clickedRegion];
                    dragOffsetX = mouseX - region.x;
                    dragOffsetY = mouseY - region.y;
                    updatePreview();
                    return;
                }
                
                selectedRegion = null;
                startX = mouseX;
                startY = mouseY;
                isDrawing = true;
                currentRect = { x: startX, y: startY, width: 0, height: 0 };
            });

            previewCanvas.addEventListener('mousemove', (e) => {
                if (currentMode !== 'freehand') return;
                
                const rect = previewCanvas.getBoundingClientRect();
                const scaleX = sourceImage.width / rect.width;
                const scaleY = sourceImage.height / rect.height;
                
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                if (isResizing && selectedRegion !== null) {
                    const region = freehandRegions[selectedRegion];
                    
                    switch(resizeHandle) {
                        case 'nw':
                            const newWidth1 = region.width + (region.x - mouseX);
                            const newHeight1 = region.height + (region.y - mouseY);
                            if (newWidth1 > 10 && newHeight1 > 10) {
                                region.x = mouseX;
                                region.y = mouseY;
                                region.width = newWidth1;
                                region.height = newHeight1;
                            }
                            break;
                        case 'ne':
                            const newWidth2 = mouseX - region.x;
                            const newHeight2 = region.height + (region.y - mouseY);
                            if (newWidth2 > 10 && newHeight2 > 10) {
                                region.y = mouseY;
                                region.width = newWidth2;
                                region.height = newHeight2;
                            }
                            break;
                        case 'sw':
                            const newWidth3 = region.width + (region.x - mouseX);
                            const newHeight3 = mouseY - region.y;
                            if (newWidth3 > 10 && newHeight3 > 10) {
                                region.x = mouseX;
                                region.width = newWidth3;
                                region.height = newHeight3;
                            }
                            break;
                        case 'se':
                            region.width = mouseX - region.x;
                            region.height = mouseY - region.y;
                            if (region.width < 10) region.width = 10;
                            if (region.height < 10) region.height = 10;
                            break;
                        case 'n':
                            const newHeight5 = region.height + (region.y - mouseY);
                            if (newHeight5 > 10) {
                                region.y = mouseY;
                                region.height = newHeight5;
                            }
                            break;
                        case 's':
                            region.height = mouseY - region.y;
                            if (region.height < 10) region.height = 10;
                            break;
                        case 'w':
                            const newWidth6 = region.width + (region.x - mouseX);
                            if (newWidth6 > 10) {
                                region.x = mouseX;
                                region.width = newWidth6;
                            }
                            break;
                        case 'e':
                            region.width = mouseX - region.x;
                            if (region.width < 10) region.width = 10;
                            break;
                    }
                    
                    updateRegionsList();
                    updatePreview();
                    return;
                }
                
                if (isDragging && selectedRegion !== null) {
                    const region = freehandRegions[selectedRegion];
                    region.x = Math.max(0, Math.min(mouseX - dragOffsetX, sourceImage.width - region.width));
                    region.y = Math.max(0, Math.min(mouseY - dragOffsetY, sourceImage.height - region.height));
                    updatePreview();
                    return;
                }
                
                if (isDrawing) {
                    currentRect.width = mouseX - startX;
                    currentRect.height = mouseY - startY;
                    updatePreview();
                    return;
                }
                
                const handleInfo = getResizeHandle(mouseX, mouseY);
                if (handleInfo) {
                    const cursors = {
                        'nw': 'nw-resize',
                        'ne': 'ne-resize',
                        'sw': 'sw-resize',
                        'se': 'se-resize',
                        'n': 'n-resize',
                        's': 's-resize',
                        'w': 'w-resize',
                        'e': 'e-resize'
                    };
                    previewCanvas.style.cursor = cursors[handleInfo.handle];
                } else if (getRegionAtPoint(mouseX, mouseY) !== null) {
                    previewCanvas.style.cursor = 'move';
                } else {
                    previewCanvas.style.cursor = 'crosshair';
                }
            });

            previewCanvas.addEventListener('mouseup', (e) => {
                if (currentMode !== 'freehand') return;
                
                if (isResizing) {
                    isResizing = false;
                    resizeHandle = null;
                    updatePreview();
                    return;
                }
                
                if (isDragging) {
                    isDragging = false;
                    updatePreview();
                    return;
                }
                
                if (isDrawing) {
                    isDrawing = false;
                    
                    if (Math.abs(currentRect.width) > 10 && Math.abs(currentRect.height) > 10) {
                        const normalizedRect = {
                            x: currentRect.width < 0 ? startX + currentRect.width : startX,
                            y: currentRect.height < 0 ? startY + currentRect.height : startY,
                            width: Math.abs(currentRect.width),
                            height: Math.abs(currentRect.height)
                        };
                        
                        freehandRegions.push(normalizedRect);
                        selectedRegion = freehandRegions.length - 1;
                        updateRegionsList();
                    }
                    
                    currentRect = null;
                    updatePreview();
                }
            });

            previewCanvas.addEventListener('mouseleave', () => {
                if (isDrawing) {
                    isDrawing = false;
                    currentRect = null;
                    updatePreview();
                }
                if (isDragging) {
                    isDragging = false;
                }
                if (isResizing) {
                    isResizing = false;
                    resizeHandle = null;
                }
                previewCanvas.style.cursor = 'crosshair';
            });

            function updateRegionsList() {
                if (freehandRegions.length === 0) {
                    regionsList.classList.add('hidden');
                    return;
                }

                regionsList.classList.remove('hidden');
                document.getElementById('regionCount').textContent = freehandRegions.length;
                regionsContainer.innerHTML = '';

                freehandRegions.forEach((region, index) => {
                    const item = document.createElement('div');
                    item.className = 'region-card';
                    item.innerHTML = `
                        <div class="region-info">
                            <div class="region-number">${index + 1}</div>
                            <div class="region-size">${Math.round(region.width)} × ${Math.round(region.height)}px</div>
                        </div>
                        <button class="btn-icon-delete" onclick="deleteRegion(${index})">
                            <i data-feather="x"></i>
                        </button>
                    `;
                    regionsContainer.appendChild(item);
                });
                
                feather.replace();
            }

            function deleteRegion(index) {
                freehandRegions.splice(index, 1);
                if (selectedRegion === index) {
                    selectedRegion = null;
                } else if (selectedRegion > index) {
                    selectedRegion--;
                }
                updateRegionsList();
                updatePreview();
            }

            function getRegionAtPoint(x, y) {
                for (let i = freehandRegions.length - 1; i >= 0; i--) {
                    const region = freehandRegions[i];
                    if (x >= region.x && x <= region.x + region.width &&
                        y >= region.y && y <= region.y + region.height) {
                        return i;
                    }
                }
                return null;
            }

            function getResizeHandle(x, y) {
                for (let i = freehandRegions.length - 1; i >= 0; i--) {
                    const region = freehandRegions[i];
                    const handles = getHandlePositions(region);
                    
                    for (const [handle, pos] of Object.entries(handles)) {
                        if (Math.abs(x - pos.x) <= handleSize && Math.abs(y - pos.y) <= handleSize) {
                            return { regionIndex: i, handle };
                        }
                    }
                }
                return null;
            }

            function getHandlePositions(region) {
                return {
                    'nw': { x: region.x, y: region.y },
                    'ne': { x: region.x + region.width, y: region.y },
                    'sw': { x: region.x, y: region.y + region.height },
                    'se': { x: region.x + region.width, y: region.y + region.height },
                    'n': { x: region.x + region.width / 2, y: region.y },
                    's': { x: region.x + region.width / 2, y: region.y + region.height },
                    'w': { x: region.x, y: region.y + region.height / 2 },
                    'e': { x: region.x + region.width, y: region.y + region.height / 2 }
                };
            }

            function drawResizeHandles(region, isSelected) {
                const handles = getHandlePositions(region);
                
                ctx.fillStyle = isSelected ? '#FF6B9D' : '#8B5CF6';
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                
                for (const pos of Object.values(handles)) {
                    ctx.fillRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
                    ctx.strokeRect(pos.x - handleSize / 2, pos.y - handleSize / 2, handleSize, handleSize);
                }
            }

            clearRegionsBtn.addEventListener('click', () => {
                freehandRegions = [];
                selectedRegion = null;
                updateRegionsList();
                updatePreview();
            });

            function updatePreview() {
                if (!sourceImage) return;

                previewCanvas.width = sourceImage.width;
                previewCanvas.height = sourceImage.height;
                ctx.drawImage(sourceImage, 0, 0);

                if (currentMode === 'grid') {
                    drawGridPreview();
                } else {
                    drawFreehandPreview();
                }
            }

            function drawGridPreview() {
                const top = parseInt(document.getElementById('topBorder').value) || 0;
                const bottom = parseInt(document.getElementById('bottomBorder').value) || 0;
                const left = parseInt(document.getElementById('leftBorder').value) || 0;
                const right = parseInt(document.getElementById('rightBorder').value) || 0;
                const rows = parseInt(document.getElementById('rows').value) || 1;
                const cols = parseInt(document.getElementById('cols').value) || 1;
                const marginX = parseInt(document.getElementById('marginX').value) || 0;
                const marginY = parseInt(document.getElementById('marginY').value) || 0;

                const x0 = left;
                const y0 = top;
                const x1 = sourceImage.width - right;
                const y1 = sourceImage.height - bottom;

                ctx.strokeStyle = '#FF6B9D';
                ctx.lineWidth = 2;
                ctx.strokeRect(x0, y0, x1 - x0, y1 - y0);

                const availableWidth = x1 - x0 - (cols - 1) * marginX;
                const availableHeight = y1 - y0 - (rows - 1) * marginY;
                const cellW = availableWidth / cols;
                const cellH = availableHeight / rows;

                ctx.strokeStyle = '#8B5CF6';
                ctx.lineWidth = 2;

                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const cellX = x0 + c * (cellW + marginX);
                        const cellY = y0 + r * (cellH + marginY);
                        ctx.strokeRect(cellX, cellY, cellW, cellH);
                    }
                }

                if (marginX > 0 || marginY > 0) {
                    ctx.fillStyle = 'rgba(139, 92, 246, 0.15)';
                    
                    for (let c = 1; c < cols; c++) {
                        const marginStartX = x0 + c * cellW + (c - 1) * marginX;
                        ctx.fillRect(marginStartX, y0, marginX, y1 - y0);
                    }
                    
                    for (let r = 1; r < rows; r++) {
                        const marginStartY = y0 + r * cellH + (r - 1) * marginY;
                        ctx.fillRect(x0, marginStartY, x1 - x0, marginY);
                    }
                }
            }

            function drawFreehandPreview() {
                freehandRegions.forEach((region, index) => {
                    const isSelected = index === selectedRegion;
                    
                    ctx.strokeStyle = isSelected ? '#FF6B9D' : '#8B5CF6';
                    ctx.lineWidth = isSelected ? 3 : 2;
                    ctx.strokeRect(region.x, region.y, region.width, region.height);
                    
                    if (isSelected) {
                        ctx.fillStyle = 'rgba(255, 107, 157, 0.1)';
                        ctx.fillRect(region.x, region.y, region.width, region.height);
                    }
                    
                    drawResizeHandles(region, isSelected);
                    
                    ctx.fillStyle = isSelected ? '#FF6B9D' : '#8B5CF6';
                    ctx.font = 'bold 16px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';
                    ctx.fillText(`${index + 1}`, region.x + 8, region.y + 22);
                });

                if (isDrawing && currentRect) {
                    ctx.strokeStyle = '#60A5FA';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
                    ctx.setLineDash([]);
                }
            }

            function cropImages() {
                if (!sourceImage) return;

                croppedImages = [];
                croppedGrid.innerHTML = '';

                if (currentMode === 'grid') {
                    cropGridMode();
                } else {
                    cropFreehandMode();
                }

                document.getElementById('imageCount').textContent = croppedImages.length;
                croppedSection.classList.remove('hidden');
                feather.replace();
            }

            function cropGridMode() {
                const top = parseInt(document.getElementById('topBorder').value) || 0;
                const bottom = parseInt(document.getElementById('bottomBorder').value) || 0;
                const left = parseInt(document.getElementById('leftBorder').value) || 0;
                const right = parseInt(document.getElementById('rightBorder').value) || 0;
                const rows = parseInt(document.getElementById('rows').value) || 1;
                const cols = parseInt(document.getElementById('cols').value) || 1;
                const marginX = parseInt(document.getElementById('marginX').value) || 0;
                const marginY = parseInt(document.getElementById('marginY').value) || 0;

                const x0 = left;
                const y0 = top;
                const x1 = sourceImage.width - right;
                const y1 = sourceImage.height - bottom;

                const availableWidth = x1 - x0 - (cols - 1) * marginX;
                const availableHeight = y1 - y0 - (rows - 1) * marginY;
                const cellW = Math.floor(availableWidth / cols);
                const cellH = Math.floor(availableHeight / rows);

                let index = 1;
                for (let r = 0; r < rows; r++) {
                    for (let c = 0; c < cols; c++) {
                        const sx = x0 + c * (cellW + marginX);
                        const sy = y0 + r * (cellH + marginY);

                        const canvas = document.createElement('canvas');
                        canvas.width = cellW;
                        canvas.height = cellH;
                        const cellCtx = canvas.getContext('2d');

                        cellCtx.drawImage(
                            sourceImage,
                            sx, sy, cellW, cellH,
                            0, 0, cellW, cellH
                        );

                        const dataUrl = canvas.toDataURL('image/png');
                        const imageName = `cropped_${index}`;
                        croppedImages.push({ index, name: imageName, dataUrl });

                        const item = document.createElement('div');
                        item.className = 'crop-tile';
                        item.innerHTML = `
                            <img src="${dataUrl}" alt="${imageName}">
                            <div class="crop-overlay">
                                <div class="crop-name" onclick="editImageName(${index - 1}, event)">
                                    <span id="imageName${index - 1}">${imageName}</span>
                                    <i data-feather="edit-2"></i>
                                </div>
                                <button class="btn-download" onclick="downloadImage(${index - 1})">
                                    <i data-feather="download"></i>
                                </button>
                            </div>
                        `;
                        croppedGrid.appendChild(item);

                        index++;
                    }
                }
            }

            function cropFreehandMode() {
                if (freehandRegions.length === 0) {
                    alert('Please draw at least one region to crop!');
                    return;
                }

                freehandRegions.forEach((region, index) => {
                    const canvas = document.createElement('canvas');
                    canvas.width = Math.floor(region.width);
                    canvas.height = Math.floor(region.height);
                    const cellCtx = canvas.getContext('2d');

                    cellCtx.drawImage(
                        sourceImage,
                        region.x, region.y, region.width, region.height,
                        0, 0, region.width, region.height
                    );

                    const dataUrl = canvas.toDataURL('image/png');
                    const imageName = `region_${index + 1}`;
                    croppedImages.push({ index: index + 1, name: imageName, dataUrl });

                    const item = document.createElement('div');
                    item.className = 'crop-tile';
                    item.innerHTML = `
                        <img src="${dataUrl}" alt="${imageName}">
                        <div class="crop-overlay">
                            <div class="crop-name" onclick="editImageName(${index}, event)">
                                <span id="imageName${index}">${imageName}</span>
                                <i data-feather="edit-2"></i>
                            </div>
                            <button class="btn-download" onclick="downloadImage(${index})">
                                <i data-feather="download"></i>
                            </button>
                        </div>
                    `;
                    croppedGrid.appendChild(item);
                });
            }

            function editImageName(index, event) {
                event.stopPropagation();
                const nameSpan = document.getElementById(`imageName${index}`);
                const currentName = nameSpan.textContent;
                
                const input = document.createElement('input');
                input.type = 'text';
                input.value = currentName;
                input.className = 'name-input';
                
                nameSpan.parentNode.replaceChild(input, nameSpan);
                input.focus();
                input.select();
                
                const finishEdit = () => {
                    const newName = input.value.trim() || currentName;
                    croppedImages[index].name = newName;
                    
                    const newSpan = document.createElement('span');
                    newSpan.id = `imageName${index}`;
                    newSpan.textContent = newName;
                    input.parentNode.replaceChild(newSpan, input);
                };
                
                input.addEventListener('blur', finishEdit);
                input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        finishEdit();
                    }
                });
            }

            function downloadImage(index) {
                const link = document.createElement('a');
                link.download = `${croppedImages[index].name}.png`;
                link.href = croppedImages[index].dataUrl;
                link.click();
            }

            async function downloadAllAsZip() {
                const zip = new JSZip();
                
                croppedImages.forEach((img) => {
                    const base64Data = img.dataUrl.split(',')[1];
                    zip.file(`${img.name}.png`, base64Data, { base64: true });
                });

                const blob = await zip.generateAsync({ type: 'blob' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = 'cropped_images.zip';
                link.click();
            }

            function reset() {
                sourceImage = null;
                croppedImages = [];
                freehandRegions = [];
                selectedRegion = null;
                isDragging = false;
                isResizing = false;
                isDrawing = false;
                imageInput.value = '';
                uploadSection.style.display = 'block';
                toolsSection.classList.add('hidden');
                croppedSection.classList.add('hidden');
                croppedGrid.innerHTML = '';
                emptyState.style.display = 'flex';
                previewCanvas.style.display = 'none';
                ctx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                updateRegionsList();
            }

            // Event listeners
            document.getElementById('updatePreview').addEventListener('click', updatePreview);
            document.getElementById('cropButton').addEventListener('click', cropImages);
            document.getElementById('resetButton').addEventListener('click', reset);
            document.getElementById('downloadAllButton').addEventListener('click', downloadAllAsZip);

            ['topBorder', 'bottomBorder', 'leftBorder', 'rightBorder', 'rows', 'cols', 'marginX', 'marginY'].forEach(id => {
                document.getElementById(id).addEventListener('input', () => {
                    if (currentMode === 'grid') {
                        updatePreview();
                    }
                });
            });
        </script>
    </body>
</html>